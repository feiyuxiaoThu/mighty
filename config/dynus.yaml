# --------------------------------------------------------------------------
# Copyright 2024, Kota Kondo, Aerospace Controls Laboratory
# Massachusetts Institute of Technology
# All Rights Reserved
# Authors: Kota Kondo, et al.
# See LICENSE file for the license information
# --------------------------------------------------------------------------

# This is the configuration file for the dynus package
dynus_node:

    ros__parameters:

        # Vehicle type
        vehicle_type: "uav"       # ["uav", "ground_robot", "qudruped_robot"]
        provide_goal_in_global_frame: false # [-] Provide goal in the global frame
        use_hardware: false      # [-] Use hardware
        
        # Sensor input
        use_lidar: true                 # [-] Use lidar
        use_depth_camera: true          # [-] Use depth camera

        # Flight mode (terminal_goal, exploration) Note: if we use exploration, "use_frontiers" should be true
        flight_mode: "terminal_goal"    # ["terminal_goal", "exploration", "tracking", "adversarial"]

        # Visual (for real-world implementation, visual should be 0)
        visual_level: 2                 # [-] visual level (0: no visual, 1: minimal visual, 2: full visual)

        # Global & Local planner parameters
        planner_mode: "dynus"           # ["dynus"]
        plan_only_in_free_space: false   # [-] Plan only in free space - if true, the planner will plan only in free space
        use_free_space: false            # [-] Use free space for the global planner - if we want to use "safe" mode, this should be true
        
        # Gloabl planner parameters
        global_planner: "sjps"                           # ["sjps"] - "dgp": Dynus Global Planner (DGP), "sjps": Static JPS, "dastar": Dynamic A* without waiting option in motions
        factor_dgp: 1.0                                 # do not change - [m] actual_resolution = factor_dgp * (resolution of the map)
        inflation_dgp: 0.45                              # [m] The obstacles are inflated (to run DGP) by this amount
        free_inflation_dgp: 0.0                         # [m] The free space is inflated (to run DGP) by this amount
        x_min: -1000.0                                  # [m] x_min of the map - TODO: x_min, x_max, y_min, y_max doesn't limit the map size. It's only used for convext decomposition and gurobi solver's search range
        x_max: 1000.0                                   # [m] x_max of the map
        y_min: -1000.0                                  # [m] y_min of the map
        y_max: 1000.0                                   # [m] y_max of the map
        z_min: 0.0                                      # [m] points below this are considered ground
        z_max: 5.0                                      # [m] DGP is run with resolution=factor_dgp*(resolution of the map)
        use_raw_path: false                             # if true, the planner will return the raw path from DGP
        dgp_timeout_duration_ms: 10000                  # [ms] Timeout duration for the DGP
        use_free_start: true                            # [-] Use free start for the DGP
        free_start_factor: 1.0                           # [-] Factor for the free start
        use_free_goal: false                             # [-] Use free goal for the DGP
        free_goal_factor: 2.0                           # [-] Factor for the free goal
        delete_too_close_points_in_global_path: true    # [-] Delete too close points in the global path - recommended to be true for dynamic A*
        node_size_factor_for_occupied: 0.5              # [-] Node size factor for the occupied
        node_size_factor_for_free: 0.6                  # [-] Node size factor for the free cells
        use_z_axis_bottom_inflation: false              # [-] Use z axis bottom inflation for the global planner
        global_planner_huristic_weight: 0.01             # [-] Weight for the heuristic in the global planner
        num_N: 4                                    # [-] Number of segments
        max_dist_vertexes: 1.5                      # [m] Maximum distance between two consecutive vertexes

        # Path push visualization parameters (if we wanna visualize the path push - just flip all the flags)
        use_state_update: true                  # [-] Use ego-agent's state update - if false, we fix the ego-agent's state (this is useful for path push visualization)
        use_random_color_for_global_path: false # [-] Use random color for the global path - this is useful for path push visualization
        use_path_push_for_visualization: false  # [-] If true, we just do global planning and return true in replan() function. This is useful for the paper visualization.

        # Dynamic obstacle push parameters
        use_dynamic_push: true                     # [-] Use dynamic push
        dyn_obst_global_planner_push_k: 0.5            # [-] push k for the global planner
        dyn_obst_global_planner_push_cov_p_alpha: 10.0   # [-] push cov_p alpha for the global planner
        dyn_obst_replusion_max: 1.0                     # [m] Maximum repulsion distance (per obstacle) for the dynamic obstacles

        # Static obstacle push parameters
        use_static_push: true                       # [-] Use static push
        dist_discretization: 0.1                # [m] Distance discretization for the push
        max_dist_threshold_for_static_push: 2.0 # [m] Maximum distance threshold for the static push
        push_force_static: 1.0                  # [-] Push force for the static obstacles
        num_lookahead_global_path_for_push: 5   # [-] Number of global path to look ahead (from the end of the path[num_P])
        static_push_clustering_threshold: 1.5   # [m] Clustering threshold for the static push

        # Global planner benchmarking parameters
        use_benchmark: true                     # [-] Use global planner benchmarking
        file_path: "/media/kkondo/T7/dynus/tro_paper/global_planner_benchmarking/csv/dgp/num_0.csv" # path to the file to save the data
        use_only_global_planner: false          # [-] Use only global planner for the benchmarking

        # Decomposition module parameters
        local_box_size: [3.0, 3.0, 3.0]         # [m] Size of the local box (smaller, faster)
        convex_decomp_use_uncertainty_diffusion_propagation: false # [-] Use uncertainty diffusion propagation for the convex decomposition
        min_dist_from_agent_to_traj: 3.0        # [m] Minimum distance from the agent to the trajectory
        use_shrinked_box: false                 # [-] Use shrinked box for the convex decomposition
        shrinked_box_size: 0.0                  # [m] Size of the shrinked box

        # Closed-form trajectory generation parameters
        closed_form_time_allocation_adj_iter_max: 5 # [-] Maximum number of iterations for the time allocation adjustment
        closed_form_initial_factor: 1.0            # [-] Initial factors for the closed-form trajectory generation
        closed_form_factor_increment: 0.1          # [-] Factor increment for the closed-form trajectory generation
        closed_form_factor_initial_decrement: 0.1          # [-] Factor decrement for the closed-form trajectory generation

        # Initial guess parameters
        use_multiple_initial_guesses: false          # [-] Use multiple initial guesses
        num_perturbation_for_ig: 8                  # [-] Number of perturbations for the initial guess
        r_max_for_ig: 1.0                           # [m] radius for the initial guess perturbation

        # Optimization parameters
        horizon: 10.0                               # [m] Horizon
        dc: 0.01                                    # [s] Duration for the interpolation=Value of the timer pubGoal
        v_nom: 2.0                                  # [m/s] Nominal velocity
        v_max: 2.0                                  # [m/s]  max velocity
        a_max: 5.0                                 # [m/s2] max acceleration
        j_max: 30.0                                 # [m/s3] max jerk
        dynamic_weight: 1e1                         # [-] Weight of the obstacles and agents distance in the optimization
        time_weight: 1e+1                           # [-] Weight of the time cost in the optimization
        stat_weight: 1e+4                           # [-] Weight of the static obstacles in the optimization
        jerk_weight: 1e-1                           # [-] Weight of the jerk in the optimization
        dyn_constr_vel_weight: 1e+3                 # [-] Weight of the velocity constraints violation in the optimization
        dyn_constr_acc_weight: 1e+3                 # [-] Weight of the acceleration constraints violation in the optimization
        dyn_constr_jerk_weight: 1e+3                # [-] Weight of the jerk constraints violation in the optimization
        dyn_constr_bodyrate_weight: 0.0             # [-] Weight of the body rate constraints violation in the optimization
        dyn_constr_tilt_weight: 0.0                 # [-] Weight of the tilt constraints violation in the optimization
        dyn_constr_thrust_weight: 0.0              # [-] Weight of the thrust constraints violation in the optimization
        num_dyn_obst_samples: 10                  # [-] Number of samples for the dynamic obstacles in the optimization
        planner_Co: 0.3                             # [-] Collision clearance thresh for static obstacles in the optimization
        planner_Cw: 3.0                             # [-] Collision clearance thresh for dynamic obstacles in the optimization
        drone_bbox: [0.3, 0.3, 0.3]                 # [m] Size of the bounding box for the obstacles
        goal_radius: 0.5                           # [m] Radius of the goal
        goal_seen_radius: 2.0                       # [m] Radius of the goal that the drone can see and stop replanning. Note that if this number is too small, the trajectory planning becomes extremely difficult.
        second_to_last_vel_scale: 1.0               # [-] Scale for the second to last velocity vector in the optimization
        integral_resolution: 16
        hinge_mu: 1e-2
        omega_max: 0.10472 # [rad/s] Maximum angular velocity (6 deg/s)
        tilt_max_rad: 0.610865 # [rad] Maximum tilt angle (35 deg)
        f_min: 2.0                        # Minimum thrust
        f_max: 12.0                        # Maximum thrust
        mass: 1.0                         # [kg] Mass of the drone
        g: 9.81                        # [m/s^2] Gravitational acceleration
        seam_min_dist: 2.0              # [m] Minimum distance to consider a seam (to prune nearly coincident waypoints in the global path)
        fopt_threshold: 30000.0               # [-] Threshold for the fopt to consider the optimization successful

        # L-BFGS parameters
        init_turn_bf: 60.0                          # [deg] Initial turn buffer in degrees
        f_dec_coeff: 1e-3     
        cautious_factor: 1.0e-6
        past: 3
        max_linesearch: 64  
        max_iterations: 500 
        g_epsilon: 1.0e-5
        delta: 1.0e-5

        # Safe paths parameters
        num_safe_paths: 20                          # [-] Number of safe paths to discretize
        min_num_safe_paths: 3                       # [-] Minimum number of safe paths
        min_safe_path_distance: 0.3                 # [m] Distance to stop the drone
        max_safe_path_distance: 0.6                 # [m] Distance to stop the drone

        # Contingency paths parameters
        contingency_lateral_offset: 0.5             # [m] Lateral offset (how far from the center goal to other goals) for the contingency paths

        # Dynamic obstacle parameters
        traj_lifetime: 7.0                          # [s] Time to keep the trajectory
        tracking_distance_threshold: 10.0           # [m] Distance threshold for the tracking
        alpha_cov: 3.0                              # [-] Alpha for the covariance inflation for dynamic obstacles (inflation = bbox + alpha_cov * ekf_cov_p) See map_util.hpp's updateDynamicMapFromTrajs() for more details
        dynamic_obstacle_base_inflation: 0.5        # [m] Inflation for the dynamic obstacles
        max_dynamic_obstacle_inflation: 1.0         # [m] Inflation for the dynamic obstacles
        freq_dynamic_obstacle_update_to_tmap: 10.0  # [Hz] Frequency to update the dynamic obstacles to the tmap

        # Dynamic k_value parameters
        num_replanning_before_adapt: 10             # [-] Number of replanning before adapting the k_value
        default_k_value: 50                         # [-] Default k_value at the end of the trajectory
        alpha_k_value_filtering: 0.9               # [-] Alpha for the k_value adaptation
        k_value_factor: 2.0                         # [-] Factor for the k_value adaptation

        # Yaw-related parameters
        use_initial_yawing: false               # [-] Use initial yawing
        use_yaw: true                           # [-] Use yaw
        alpha_filter_dyaw: 0.85                 # [-] Filter parameter for dyaw, \in [0,1]. Higher--> More aggressive filtering
        w_max: 1.0                              # [rd/s] Maximum angular velocity. ~4.0 for Hardware
        yaw_collision_weight: 1.0             # [-] Weight for the yaw collision likelihood
        yaw_time_weight: 1.0                   # [-] Weight for the yaw time since last observed
        yaw_proximity_weight: 1.0             # [-] Weight for the yaw proximity
        yaw_velocity_weight: 0.1              # [-] Weight for the yaw velocity
        yaw_change_weight: 0.1                # [-] Weight for the yaw change
        final_yaw_weight: 0.0                  # [-] Weight for the final yaw
        cutoff_distance: 5.0                    # [m] Distance to cutoff the yaw optimization
        num_yaw_fit_poly: 4                     # [-] Number of polynomial for the yaw fitting
        yaw_fit_degree: 3                       # [-] Degree of the polynomial for the yaw fitting
        num_samples_collision_likelihood: 10    # [-] Number of samples for the collision likelihood
        num_samples_velocity_score: 10          # [-] Number of samples for the velocity score
        look_ahead_secs_for_dom: 5.0            # [s] Look ahead time for the dynamic obstacle motion
        yaw_optimization_debugging: true        # [-] Debugging the yaw optimization (publishing the yaw sequence, control points, and knots)
        yaw_spinning_threshold: 10000              # [-] if the planner keeps failing more than this number, we switch to the spinning mode
        yaw_spinning_dyaw: 1.0                  # [rd/s] Spinning dyaw

        # Simulation env parameters
        force_goal_z: false                     # [-] Force the goal to be at the certain height since Rviz GUI's goal's z is 0
        default_goal_z: 3.0                     # [m] Default goal height
        
        # Debug flags
        global_planner_verbose: false           # debug output
        debug_verbose: false                    # [-] Verbose the debug information
        dist_to_term_g_verbose: false           # [-] Verbose the distance to the terminal goal
        closed_form_traj_verbose: false         # Verbosity of closed-form traj.
        verbose_computation_time: false         # [-] Verbose the computation time

        # Map parameters
        map_buffer: 1.0                         # [m] buffer for goal & A point
        failure_map_buffer_increment: 0.0       # [m] Increment for the failure map buffer - if the planner keeps failing, we increase the buffer size -> map size
        map_buffer_velocity_factor: 0.0         # [-] Factor for the map buffer velocity
        center_shift_factor: 0.5                # [-] Factor for the center shift
        initial_wdx: 20.0                       # [m] Width of the map (should be the same as wdy assumed in trajCallback)
        initial_wdy: 20.0                       # [m] Depth of the map (should be the same as wdx assumed in trajCallback)
        initial_wdz: 3.0                       # [m] Height of the map
        max_wdx: 20.0                           # [m] Maximum width of the map
        max_wdy: 20.0                           # [m] Maximum depth of the map
        max_wdz: 4.0                           # [m] Maximum height of the map
        min_wdx: 10.0                           # [m] Minimum width of the map
        min_wdy: 10.0                           # [m] Minimum depth of the map
        min_wdz: 2.0                           # [m] Minimum height of the map
        lidar_max_range: 15.0                   # [m] Maximum range of the lidar
        use_map_res_adaptation: false            # [-] Use map resolution adaptation
        map_res_adaptation_decrement: 0.1      # [m] Decrement for the map resolution adaptation
        map_res_adaptation_threshold: 10        # [-] If plan fails this many times, we decrease the map resolution by map_res_adaptation_decrement
        dynus_map_res: 0.15              # [m] Resolution of the map
        dynus_map_res_min: 0.15          # [m] Minimum resolution of the map
        octomap_res: 0.15                # [m] Resolution of the octomap [Note: rule of thumb: equal to or smaller than dynus_map_res]
        tmap_update_rate: 20.0          # [Hz] Rate to update the tmap
        
        # Frontiers parameters
        use_frontiers: false                         # [-] Use frontiers
        use_only_d435_for_frontiers: true           # [-] Use only D435 for frontiers
        max_z_diff_from_frontier_to_camera: 50.0    # [m] Minimum z difference from the frontier to the camera
        min_dist_from_frontier_to_camera: 0.01      # [m] Minimum distance from the frontier to the camera
        frontier_update_alpha: 0.5                  # [-] Alpha for the frontier update new = alpha * new + (1-alpha) * old
        d435_depth_min: 0.01                        # [m] Minimum depth to cut off the frontiers for the D435
        use_mean_based_best_frontier: false         # [-] Use mean-based best frontier
        no_visible_frontiers_threshold: 10          # [-] Number of no visible frontiers to switch to the exploration mode
        desired_velocity_cost_weight: 10.0          # [-] Weight of the desired velocity cost in the optimization
        dist_from_z_axis_weight: 0.0                # [-] Weight of the distance from the z axis in the optimization
        dist_to_prev_best_frontier_weight: 0.001    # [-] Weight of the distance to the previous best frontier in the optimization
        positive_z_camera_weight: 100.0             # [-] Weight of the positive z camera in the optimization
        goal_proximity_weight: 0.0                  # [-] Weight of the goal proximity in the optimization
        info_gain_cost_weight: 10.0                 # [-] Weight of the information gain cost in the optimization
        frontier_neighbor_thresh_for_info_gain: 1.0 # [m] Distance threshold for the frontier neighbor to calculate the information gain
        frontier_search_buffer: 2.0                 # [m] Buffer for the frontier search
        frontier_min_known_free_thresh: 1           # [-] Minimum known free threshold for the frontier
        frontier_min_unknown_thresh: 2              # [-] Minimum unknown threshold for the frontier
        
        # Communication delay parameters
        use_comm_delay_inflation: true  # [-] Use communication delay inflation
        comm_delay_inflation_alpha: 0.2 # [-] Alpha for the communication delay inflation
        comm_delay_inflation_max: 0.1   # [m] Maximum communication delay inflation
        comm_delay_filter_alpha: 0.9    # [-] Alpha for the communication delay filter new_comm_delay = alpha * new_comm_delay + (1-alpha) * old_comm_delay

        # Safety check parameters
        safety_check_dt: 0.05            # [s] Discretization time step for the safety check

        # Simultation related parameters
        depth_camera_depth_max: 10.0    # [m] d435 depth in simulation
        fov_visual_depth: 10.0          # [m] FOV visual depth
        fov_visual_x_deg: 76.0          # [deg] FOV visual x degree
        fov_visual_y_deg: 47.0          # [deg] FOV visual y degree

        # Obstacle tracking/prediction parameters
        use_adaptive_kf: true                       # [-] Use adaptive KF
        adaptive_kf_alpha: 0.90                     # [-] Alpha for the adaptive KF (if you set it to 1.0, it becomes a standard KF)
        adaptive_kf_dt: 0.1                         # [s] Time step for the adaptive KF
        cluster_tolerance: 1.0                      # [m] Tolerance for the clustering
        min_cluster_size: 20                        # [-] Minimum cluster pointcloud size
        max_cluster_size: 70                       # [-] Maximum cluster pointcloud size
        prediction_horizon: 1.0                     # [s] Prediction horizon
        prediction_dt: 0.1                          # [s] Time step for the prediction
        time_to_delete_old_obstacles: 5.0           # [s] Time to delete old obstacles
        cluster_bbox_cutoff_size: 2.0               # [m] Size of the bounding box for the clustering
        use_life_time_for_box_visualization: true  # [-] Use life time for the box visualization - if false, we keep the box until the end of the simulation
        box_visualization_duration: 1.0             # [s] Duration to visualize the bounding box
        velocity_threshold: 0.8                     # [m/s] Velocity threshold to characterize as dynamic obstacles
        acceleration_threshold: 2.0                 # [m/s2] Acceleration threshold to characterize as dynamic obstacles

        # Octomap parameters
        use_height_map: false           # [bool] Use height map for insertion
        use_colored_map: false          # [bool] Use colored map for insertion
        color_factor: 0.8               # [double] Factor for map coloring
        point_cloud_min_x: -200.0       # [m] Minimum x coordinate for point cloud
        point_cloud_max_x: 200.0        # [m] Maximum x coordinate for point cloud
        point_cloud_min_y: -200.0       # [m] Minimum y coordinate for point cloud
        point_cloud_max_y: 200.0        # [m] Maximum y coordinate for point cloud
        point_cloud_min_z: 0.5          # [m] Minimum height of points to consider for insertion
        point_cloud_max_z: 8.0         # [m] Maximum height of points to consider for insertion
        filter_speckles: true          # [bool] Enable speckle filtering
        filter_ground_plane: false      # [bool] Enable ground plane filtering
        ground_filter.distance: 0.04    # [m] Distance threshold to consider a point as ground
        ground_filter.angle: 0.15       # [rad] Angular threshold for ground plane filtering
        ground_filter.plane_distance: 0.07  # [m] Plane distance threshold for ground filtering
        use_decay: true                # [bool] Use octomap time decay
        decay_duration: 3.0             # [s] Time to decay the octomap
        sensor_model.occupancy_thres: 0.5 # [probability] Sensor model threshold for occupancy
        sensor_model.hit: 0.51           # [probability] Sensor model probability for a hit
        sensor_model.miss: 0.40          # [probability] Sensor model probability for a miss
        sensor_model.min: 0.12          # [probability] Minimum probability clamp for sensor model
        sensor_model.max: 0.97          # [probability] Maximum probability clamp for sensor model
        compress_map: true              # [bool] Compress the map losslessly
        color.r: 0.0                    # [double] Red channel for map color
        color.g: 0.0                    # [double] Green channel for map color
        color.b: 1.0                    # [double] Blue channel for map color
        color.a: 1.0                    # [double] Alpha channel for map color
        color_free.r: 0.0               # [double] Red channel for free space color
        color_free.g: 1.0               # [double] Green channel for free space color
        color_free.b: 0.0               # [double] Blue channel for free space color
        color_free.a: 0.5               # [double] Alpha channel for free space color
        latched_topics: false           # [bool] Enable latched topics
        publish_free_space: true        # [bool] Publish free space information
        lidar_insert_hz: 100.0            # [Hz] Frequency to insert the lidar point cloud
        depth_camera_insert_hz: 10.0     # [Hz] Frequency to insert the depth camera point cloud
        remove_close_points: false        # [bool] Remove points that are too close to the camera
        remove_close_points_radius: 0.4            # [m] Minimum distance to remove points

        # Ground robot control gains
        ground_robot_kv: 1.0            # [-] Ground robot velocity gain
        ground_robot_kdist: 2.5         # [-] Ground robot distance gain
        ground_robot_kw: 1.0            # [-] Ground robot angular velocity gain
        ground_robot_kyaw: 2.0          # [-] Ground robot yaw gain
        ground_robot_kalpha: 1.5        # [-] Ground robot alpha gain

        # Quadruped PID gains
        qudruped_kp_x: 2.0              # [-] Quadruped proportional gain for x
        qudruped_ki_x: 0.1              # [-] Quadruped integral gain for x
        qudruped_kd_x: 0.1              # [-] Quadruped derivative gain for x
        qudruped_kp_y: 0.3              # [-] Quadruped proportional gain for y
        qudruped_ki_y: 0.01             # [-] Quadruped integral gain for y
        qudruped_kd_y: 0.3              # [-] Quadruped derivative gain for y

        # Object tracking parameters
        ot_rel_x: 4.0               # [m] Relative x position for object tracking
        ot_rel_y: 0.0               # [m] Relative y position for object tracking
        ot_rel_z: 0.0               # [m] Relative z position for object tracking8efc5c115f60ad5876cf9fc3b18577c24048ef93